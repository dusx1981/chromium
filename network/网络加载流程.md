# Chromium 网页加载流程分析（基于 Mojo IPC）

本文基于 Chromium 源码，分析 **通过 Mojo IPC 实现的网页加载完整流程**。涉及 **浏览器进程 (Browser Process)** 和 **渲染进程 (Renderer Process)**，核心组件包括：

* **浏览器进程**：`NavigationURLLoaderImpl`
* **渲染进程**：`NavigationBodyLoader`
* **IPC 框架**：Mojo（接口调用 + 数据管道）

---

## 1. 导航初始化（浏览器进程）

* **触发**：用户输入 URL / 点击链接
* **NavigationController** 创建 **NavigationRequest**
* **核心对象**：`NavigationURLLoaderImpl` 被实例化，负责整个加载

### 初始化内容

* 参数：`BrowserContext`、`StoragePartition`、`NavigationRequestInfo` (URL、HTTP 方法等)
* 创建 **Mojo 端点**：

  * `network::mojom::URLLoader`
  * `network::mojom::URLLoaderClient`

### 代码入口

```cpp
NavigationURLLoaderImpl::Start() {
  // 初始化加载器工厂（网络 / 非网络）
  Restart(); // 开始加载请求
}
```

---

## 2. 请求处理与拦截（浏览器进程）

* **拦截器链**：`CreateInterceptors()` 创建一组 `NavigationLoaderInterceptor`（如 Service Worker、Web Bundle）
* **拦截逻辑**：

  ```cpp
  void NavigationURLLoaderImpl::MaybeStartLoader(...) {
    if (interceptor_result) {
      StartInterceptedRequest(...);  // 使用拦截器工厂
    } else {
      StartNonInterceptedRequest(...); // 默认网络工厂
    }
  }
  ```

### 处理逻辑

* **拦截成功**：使用拦截器提供的 `URLLoaderFactory`
* **未拦截**：通过默认的 `network::mojom::URLLoaderFactory` → **网络服务 (Network Service)**

---

## 3. 网络请求与响应（网络进程）

* **请求发送**：

  * `URLLoaderFactory::CreateLoaderAndStart()` 创建 `URLLoader`
* **响应回传**：

  * 网络进程通过 Mojo → 浏览器进程

  ```cpp
  // 网络进程 → 浏览器进程
  URLLoaderClient::OnReceiveResponse(head, body_handle);
  ```
* **响应体传输**：使用 `mojo::ScopedDataPipeConsumerHandle` 流式传输

---

## 4. 响应体加载初始化（浏览器进程 → 渲染进程）

* **构建 `NavigationBodyLoader`**

  ```cpp
  navigation_params->body_loader.reset(
      new NavigationBodyLoader(...));
  ```

### 参数传递

* 响应头：`network::mojom::URLResponseHeadPtr`
* 响应体：`mojo::ScopedDataPipeConsumerHandle`
* Mojo 端点：`URLLoaderClientEndpoints`

### 启动加载

```cpp
void NavigationBodyLoader::StartLoadingBody(Client* client) {
  BindURLLoaderAndStartLoadingResponseBodyIfPossible();
}
```

---

## 5. 响应体流式处理（渲染进程）

### 数据管道监听

* `NavigationBodyLoader` 使用 **mojo::SimpleWatcher** 监听可读事件

```cpp
void NavigationBodyLoader::OnReadable(MojoResult unused) {
  ReadFromDataPipe(); // 读取数据
}
```

### 数据解码模式

* **主线程模式**：`MainThreadBodyReader` 直接解码（小文件）
* **后台线程模式**：`OffThreadBodyReader` 在 Worker 线程解码（大文件优化）

### 数据传递

* 回调：`client_->BodyDataReceived(data)`
* 数据传给 **Blink** 的 `DocumentLoader` 和 `PreloadScanner`

---

## 6. 重定向处理

### 浏览器进程

* **接收回调**：`OnReceiveRedirect()`
* **处理逻辑**：

```cpp
void NavigationURLLoaderImpl::FollowRedirect(...) {
  ResetForFollowRedirect(); // 重置
  Restart(); // 重新请求
}
```

### 渲染进程

* 重定向信息传递：`WebNavigationParams::RedirectInfo`
* `NavigationBodyLoader` 被销毁并重建

---

## 7. 加载完成与错误处理

### 浏览器进程

* 网络进程回调：`OnComplete(status)`
* 转发给渲染进程：

```cpp
void NavigationBodyLoader::OnComplete(...) {
  has_received_completion_ = true;
  NotifyCompletionIfAppropriate();
}
```

### 渲染进程

* 调用：`client_->BodyLoadingFinished(...)`
* 错误封装：`WebURLError::Create(status, original_url_)`

---

## 8. 资源加载通知

* **资源事件**：

  * 开始 → 重定向 → 完成
* **实现**：`ResourceLoadInfoNotifierWrapper`

```cpp
resource_load_info_notifier_wrapper_
    ->NotifyResourceResponseReceived(...);
```

---

## 核心 Mojo 接口与数据流

### 接口

* `network::mojom::URLLoader`：启动/取消请求
* `network::mojom::URLLoaderClient`：响应回调（头、体、重定向、完成）
* `mojo::DataPipe`：响应体流式传输

### 数据流路径

```
浏览器进程 → (Mojo IPC) → 网络进程 → (HTTP请求) → 服务器
服务器 → (HTTP响应) → 网络进程 → (Mojo DataPipe) → 浏览器进程
浏览器进程 → (Mojo IPC) → 渲染进程
```

---

## 总结

* **完整流程**：
  导航初始化 → 请求拦截 → 网络请求 → 响应处理 → 流式加载 → 完成/错误

* **Mojo 的作用**：

  * 进程解耦（Browser / Network / Renderer）
  * 高效数据传输（DataPipe 避免内存拷贝）

* **优化点**：

  * **OffThreadBodyReader**：后台线程解码，减少主线程阻塞
  * **拦截器链**：Service Worker 支持离线缓存

* **错误处理**：

  * Mojo 连接断开 → `OnConnectionClosed()`
  * 标记加载失败

该流程保证了 **导航的安全性** 与 **资源加载的高效性**，同时通过 **Mojo IPC 实现跨进程通信和隔离**。
